---
alwaysApply: true
---

## ğŸŒ Doctolib-Inspired Tech Context (Adapted to React + Node.js + PostgreSQL)

### ğŸ¯ Goal of this Rule

- **Ground** all exercises and explanations in a **Doctolib-like environment**
- **Adapt** the original Ruby on Rails monolith description to the interview stack:
  - **Frontend**: React 18 + TypeScript
  - **Backend**: Node.js + Express (TypeScript when possible)
  - **Database**: PostgreSQL
  - **Testing**: Jest (+ React Testing Library / Supertest)
- **Preserve** Doctolibâ€™s key principles: _simple but not simplistic_, _quality & testing first_, _healthcare & privacy aware_.

---

## ğŸ— Real Doctolib Stack vs Practice Stack

### Real Doctolib Stack (2025)

- **Backend**:
  - Historical **Ruby on Rails monolith** (core product)
  - Ongoing migration to **Spring Boot + Kotlin/Java** microservices
- **Frontend**: React + TypeScript (integrated in the Rails monolith)
- **Mobile**: React Native, Swift, Kotlin
- **Infrastructure**: PostgreSQL, Kubernetes, Docker, AWS, GitHub Actions

### Practice Stack in This Repository

- **Frontend**: React 18 + TypeScript
- **Backend**: Node.js + Express (TypeScript preferred)
- **Database**: PostgreSQL
- **Testing**: Jest (+ React Testing Library / Supertest)

### How to Use This in Interview

- Clearly distinguish:
  - â€œIn production you use **Rails + Spring Boot/Kotlin** on top of PostgreSQL and Kubernetesâ€
  - â€œIn this exercise I implement the same **architectural principles** with **Node.js + Express + React + PostgreSQL**â€
- When you explain your design, focus on **concepts that transfer across stacks**:
  - Modular domains, clear layers (routes/controllers/services/repositories)
  - Strong typing and contracts
  - Testing strategy and observability
  - Security and privacy for healthcare data

---

## ğŸ§± High-Level Architecture (Interview Version)

### 1. Monolith, but Well-Structured

- Think **â€œmodular monolithâ€**:
  - One **Express application** for the backend
  - One **React + TS app** for the frontend
  - One **PostgreSQL database**
- Clear **domain modules** instead of microservices:
  - Examples: `patients`, `practitioners`, `appointments`, `auth`, `teleconsultations`
- Aim for **simple boundaries**, not over-engineered patterns:
  - Separate **HTTP layer / business logic / DB access**
  - Prefer **composition** over deep inheritance.

### 2. Typical Folder Structures

- **Backend (Node.js + Express + TypeScript)**

  - `src/`
    - `routes/` â†’ Express routers (HTTP endpoints only)
    - `controllers/` â†’ map requests to services, handle status codes
    - `services/` â†’ business logic (scheduling, validation, domain rules)
    - `repositories/` â†’ DB access (SQL queries / query builder / ORM)
    - `models/` or `entities/` â†’ TypeScript types/interfaces for domain objects
    - `middlewares/` â†’ auth, validation, error handling, logging
    - `config/` â†’ DB connection, environment config
    - `tests/` â†’ unit + integration (Jest)

- **Frontend (React 18 + TypeScript)**
  - `src/`
    - `components/`
      - `shared/` â†’ design system-like components (buttons, modals, inputs)
      - `features/` â†’ domain UI (appointment list, booking form)
      - `layouts/`
    - `pages/` â†’ route-level components
    - `hooks/` â†’ custom React hooks (data fetching, form logic)
    - `services/` â†’ API clients (fetch/axios, typed)
    - `types/` â†’ shared TypeScript types / DTOs
    - `utils/` â†’ formatters, helpers
    - `styles/` â†’ CSS/SCSS or CSS-in-JS
    - `tests/` â†’ component tests, hooks tests

---

## ğŸ§  Core Doctolib Principles (Tech-Agnostic)

### 1. Simple but Not Simplistic

- Prefer **straightforward solutions** that you can explain in 2 minutes.
- Avoid premature microservices, fancy patterns, or over-abstraction.
- Always ask: _â€œWill this still be understandable in 6 months by another engineer?â€_

### 2. You Build It, You Run It (Ownership)

- When designing a feature, think about:
  - **How youâ€™d monitor it** (logs, metrics)
  - **How youâ€™d debug it** (structured logs, clear errors)
  - **How youâ€™d test it** (unit, integration, end-to-end)
- Even in an interview, mention:
  - â€œIâ€™d add logs here to track Xâ€
  - â€œIâ€™d add a test case for Yâ€.

### 3. Healthcare & Privacy Awareness

- Data is **sensitive** (patients, doctors, appointments).
- Principles to keep in mind:
  - **Data minimization**: only store what you need.
  - **Least privilege**: patients vs practitioners vs admins.
  - **No secrets in code**: use environment variables (even in small demos).
  - **Auditability**: be able to understand what happened when something goes wrong.

---

## ğŸ—„ï¸ Backend (Node.js + Express + PostgreSQL)

### 1. How to Think About the Backend

- Equivalent of the Rails monolith, but in **Express + TypeScript**:
  - **Routes**: define URL + HTTP verb
  - **Controllers**: parse input, call services, choose status codes
  - **Services**: domain logic (e.g. scheduling, availability checks)
  - **Repositories**: encapsulate SQL queries
  - **Models/Types**: TypeScript interfaces/types for domain entities

### 2. PostgreSQL Usage Patterns

- Use **clear schemas** and **foreign keys**:
  - Example tables: `patients`, `practitioners`, `appointments`
  - Foreign key examples:
    - `appointments.patient_id â†’ patients.id`
    - `appointments.practitioner_id â†’ practitioners.id`
- Index where it matters:
  - Typical indexes on `(practitioner_id, date_time)` for appointment searches.
- Favor:
  - **Parameterized queries** to avoid SQL injection.
  - **Small SELECTs** (only required columns).
  - **JOINs** over many small queries (avoid N+1).

### 3. Structure of an API Endpoint (Mental Model)

When you design an endpoint, always think in this order:

1. **Route definition**
   - Path, method, URL parameters vs query parameters vs body.
2. **Validation**
   - Validate body/query/params (with a library or manual checks).
3. **Authorization**
   - Who is allowed to perform this action (patient, doctor, admin)?
4. **Business logic**
   - Call a service function to implement the feature (e.g. schedule appointment).
5. **Persistence**
   - Use repository to read/write from PostgreSQL.
6. **Response**
   - Successful response shape (status code + JSON body).
7. **Error handling**
   - Expected domain errors vs unexpected server errors.

### 4. Testing the Backend (Jest)

- **Unit tests**:
  - Services tested in isolation (mock repositories).
  - Repositories tested with a test DB (or in-memory approach).
- **Integration tests**:
  - Use Supertest + Jest to hit real Express routes.
  - Use a test DB schema with fixtures or seed data.
- Focus on:
  - Edge cases (invalid data, conflicts, missing resources).
  - Correct status codes (400, 401, 403, 404, 409, 500, etc.).

---

## ğŸ¨ Frontend (React 18 + TypeScript)

### 1. Component Design Philosophy

- Use **component-driven design**:
  - Small reusable components from a â€œdesign system spiritâ€ (like Oxygen).
  - Domain-specific components that compose the shared ones.
- Always think:
  - **Accessibility** (labels, roles, keyboard navigation).
  - **Clear error messages** (what went wrong, what to do).
  - **Loading and empty states** (not just the â€œhappy pathâ€).

### 2. Data Flow & API Calls

- API client layer in `services/`:
  - Strongly typed functions for each endpoint.
  - Centralized error handling and base URL configuration.
- Components should:
  - Use **custom hooks** for data fetching (e.g. `useAppointments`).
  - Keep UI logic in components, data logic in hooks/services.
  - Handle loading / error / success states explicitly.

### 3. TypeScript Practices

- Define **types for all important entities**:
  - `Patient`, `Practitioner`, `Appointment`, `UserRole`, `ApiError`, etc.
- Avoid `any`:
  - Use discriminated unions for statuses and roles.
  - Use utility types (`Pick`, `Omit`, `Partial`, etc.) when needed.

### 4. Testing the Frontend

- Use **React Testing Library + Jest**:
  - Test components from the user perspective (text, roles, actions).
  - Mock API calls where needed.
- Cover:
  - Happy paths (data loads correctly).
  - Error states (server error, validation error).
  - Edge UI cases (empty list, disabled buttons).

---

## âš™ï¸ CI/CD & Quality Mindset (Simplified)

Even if you donâ€™t implement full CI/CD in the interview, think like this:

- **Before merging / finishing a task mentally**:
  - Lint passes (ESLint, TypeScript).
  - Tests pass (Jest).
  - No obvious performance issues (avoid massive loops on each render).
- **PR mindset** (even if you just write code locally):
  - Small, focused changes.
  - Clear description of what you did and why.
  - Mention tests you would add or already wrote.

---

## ğŸ” Security & Privacy Basics (for the Interview)

- **Never trust input**:
  - Validate all incoming data (backend especially).
  - Sanitize or validate user-controlled parameters.
- **Avoid leaking sensitive data**:
  - Do not return internal IDs or details that are not needed.
  - Design error messages that donâ€™t leak implementation details.
- **Authentication & Authorization**:
  - Even if simplified, always mention:
    - â€œThis route should check that the user is authenticated.â€
    - â€œA patient should only access their own appointments.â€

---

## ğŸ“Š Testing Strategy (Mini Doctolib Pyramid)

Think in terms of a **testing pyramid**, but adapted to the interview scale:

1. **Unit tests** (most):
   - Pure functions, services, simple components.
2. **Integration tests**:
   - API endpoints with Express + test DB.
   - React components + API mocks end-to-end-like.
3. **Manual/E2E checks** (few, but important):
   - Launch the app.
   - Walk through key user flows (e.g. book an appointment).

Always be able to answer:

- â€œHow would you test this?â€
- â€œWhat are the most important edge cases here?â€

---

## ğŸ§­ How to Use This Context During the Interview

- When designing a feature, **place it** in this mental architecture:
  - Which **Express route**?
  - Which **service**?
  - Which **DB tables / queries**?
  - Which **React components / hooks**?
- When explaining a solution, **connect to Doctolib principles**:
  - Simplicity, testability, observability, privacy, accessibility.
- When in doubt, **prefer clarity over cleverness**.

---

## âœ… Quick Checklist Before Finalizing a Solution

- **Architecture**
  - Is the responsibility split between route â†’ controller â†’ service â†’ repository?
  - On the frontend, is logic split between component, hook, and service?
- **Data & DB**
  - Are entities and relationships clear?
  - Is there any obvious query or N+1 problem?
- **Types & Contracts**
  - Are TypeScript types clear on both backend and frontend?
  - Is the API contract (request/response shape) explicit?
- **Testing**
  - Can you name at least 3 tests youâ€™d write?
  - Have you thought about error and edge states?
- **Healthcare Context**
  - Are you careful with sensitive data and permissions?

If most answers are â€œyesâ€, youâ€™re thinking very close to how Doctolib engineers structure and reason about their featuresâ€”just with **Node.js + React + PostgreSQL** instead of Rails.
